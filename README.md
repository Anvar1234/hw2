### Техзадание:
2. Десять авторов пишут в 5 разных жанрах. Каждый автор может писать в разных жанрах.
   Сгенерировать 100 книг – список из 100 объектов Book (Id, Title, Author, Genre, Year).
   ИД – по порядку, Название – генерируется случайным набором букв, год выпуска случайный с 1995 по 2024.
   Преобразовать получившийся список в структуру Map, где ключом является сочетание Автор + Жанр,
   а значением – список книг, написанных автором в этом жанре, сортированный по году выпуска.
   Вывести в удобочитаемом виде на экран.

### Что необходимо было исправить (правки от 03_06_24):
1. Класс ApplicationRunner стр 13: **List<Book> books = BookListGenerator.generateAuthorGenreKeyBooks(new ArrayList<>(),
   new ArrayList<>())**; - мы этот метод нигде больше не используем, аргументы избыточны. Эти листы можно создать внутри метода.
#### Вопрос по 1:
в методе я оставлял возможность подсунуть любую реализацию интерфейса List в этот метод. Ну просто на будущее. 
Вдруг/чего/как-то пригодится. Так не надо? Жестко прописываем реализацию в методе? 
И как определить, когда стоит прописывать реализацию жестко, а когда оставлять поле для маневра?
2. Долго искал - а где генератор всего необходимого для книги, оказалось - в конструкторе.  Давай вынесем это в методы.
3. Структура model - impl - AuthorGenreKey.class  - выглядит странно. Этот класс не является реализацией чего-то.
4. В классе Book переменная year выбрана как строка. Которую мы сначала создаем как int, потом конвертируем в строку,
   после чего далее она используется в единственном месте для сортировки, где опять-таки из строки превращается в int. Проще сразу заявить как int.
5. TitleGenerator - стр 26 - предлагаю использовать String.join(). Строка 5 и 6 - final указать переменную большими буквами.
6. Класс Book getBook() - метод по сути делает не то что заявлено, оно инициализирует все поля. Кандидат на метод,
   который будет генерировать наполнение объекта.
7. В классе Book не должно быть поля key - оно не относится собственно к сущности Book.
   Это некая бизнес-логика которая нам нужна по задаче.
#### Пояснение по 7: 
Да, я понял, что мне не понравилось в моем решении задачи. Именно, что все перепуталось. 
Что ключ потянулся в книги, еще и добавив новый конструктор, ебатория с туСтрингом и тп.

8. Класс BookLibrary - **getLibrary(Map<AuthorGenreKey, List<Book>> implementOfMapToReturn)** - плохое название аргумента.
   Давай перепишем содержимое метода на стримы.

#### Вопрос по 8:
Тот же, что по 1 - в методе я оставил возможность подсунуть любую реализацию интерфейса List в этот метод, 
и чтобы было хоть как-то понятно, что именно в метод передавать, я и написал, типа дай мне в аргументы 
какую хочешь «реализацию мапы». Так не надо? И тоже прописывать жестко реализацию в методе?

Но по итогу мне и так не пригодилось передавать в метод какую-то реализацию. 
Я два метода переписал одной строкой на стримах и охренел от красоты, если честно.
Но вопрос остается)

9. ApplicationRunner стр 24 - тоже давай на стримы